#!python-with-venv
# pyright: strict

"""! python3.10 requirements
click==8.1.3
tabulate==0.9.0
ipython==8.11.0
tree_sitter==0.20.1
"""

from __future__ import annotations

import functools
import sys
import time
from collections.abc import Sequence, Set
from dataclasses import dataclass
from enum import Enum
from pathlib import Path
from typing import Optional, TextIO

import click
from tabulate import tabulate
from tree_sitter import Language, Node, Parser
from tree_sitter.binding import Query


class Kind(Enum):
    FUNCTION = "function"
    CLASS = "class"
    VARIABLE = "variable"


@dataclass(frozen=True)
class Symbol(object):
    qualifiers: tuple[str, ...]
    line: int  # 1-based
    kind: Kind
    file: Path

    @property
    def name(self) -> str:
        return ".".join(self.qualifiers)

    @property
    def kind_str(self) -> str:
        return str(self.kind.value)

    def __str__(self):
        return "%s [%s]" % (self.name, self.kind)


def get_ts_query_for_kind(kind: Kind) -> str:
    match kind:
        case kind.FUNCTION:
            return f"(function_definition name: (identifier) @{kind.value})"
        case kind.CLASS:
            return f"(class_definition name: (identifier) @{kind.value})"
        case kind.VARIABLE:
            return f"(assignment left: (identifier) @{kind.value})"


def get_ts_queries() -> str:
    return "\n".join(get_ts_query_for_kind(k) for k in Kind)


@functools.cache
def ts_setup() -> tuple[Parser, Query]:
    so_file = Path(__file__).parent.resolve() / "tree-sitter.so"
    Language.build_library(str(so_file), ["tree-sitter-python"])
    language = Language(str(so_file), "python")
    parser = Parser()
    parser.set_language(language)
    query = language.query(get_ts_queries())
    return parser, query


def parse_and_capture(file: Path) -> list[tuple[Node, str]]:
    parser, query = ts_setup()
    source = file.read_text().encode("utf8")
    tree = parser.parse(source)
    return query.captures(tree.root_node)


def scope_from_node(node: Node) -> tuple[str, ...]:
    scope: list[str] = []
    at = node.parent
    while at is not None:
        if at.type == "block" and at.parent is not None:
            maybe_name = at.parent.child_by_field_name("name")
            if maybe_name is not None:
                scope.append(maybe_name.text.decode("utf8"))
        at = at.parent
    return tuple(reversed(scope))


def get_symbol_from_capture(
    node: Node, name: str, file: Path, file_scope: tuple[str, ...]
) -> Optional[Symbol]:
    identifier = node.text.decode("utf8")
    scope = scope_from_node(node)
    kind = Kind(name)
    if kind is Kind.VARIABLE and len(scope) > 0:
        return None
    return Symbol(
        file_scope + scope + (identifier,),
        node.start_point[0] + 1,
        kind,
        file,
    )


def get_symbols_in_file(file: Path, file_scope: tuple[str, ...]) -> list[Symbol]:
    # TODO capture error nodes and add to results? how to warn that results are incomplete?
    candidates = parse_and_capture(file)
    maybe_symbols = [
        get_symbol_from_capture(node, name, file, file_scope)
        for node, name in candidates
    ]
    return [s for s in maybe_symbols if s is not None]


def get_scope_from_file(file: Path, base: Path) -> tuple[str, ...]:
    [*parts, last] = file.relative_to(base).parts
    match last:
        case "__init__.py":
            return tuple(parts)
        case _:
            return tuple(parts + [file.name])


def get_symbols_in_sources(sources: Set[Path]) -> list[Symbol]:
    """sources is a list of folder and/or files"""
    symbols: list[Symbol] = []
    for source in sources:
        if source.is_dir():
            for file in source.glob("**/*.py"):
                symbols.extend(
                    get_symbols_in_file(file, get_scope_from_file(file, source))
                )
        elif source.is_file():
            symbols.extend(get_symbols_in_file(source, ()))
    return symbols


def make_entries(fmt: str, symbols: Sequence[Symbol], out: TextIO):
    match fmt:
        case "human":
            make_human_entries(symbols, out)
        case "ctags":
            make_tag_entries(symbols, out)
        case "vim-telescope":
            make_vim_telescope_entries(symbols, out)
        case _:
            assert False, fmt


def make_human_entries(symbols: Sequence[Symbol], out: TextIO):
    headers = ["location", "kind", "name"]
    data = [[f"{s.file}:{s.line}", f"{s.kind_str}", f"{s.name}"] for s in symbols]
    out.write(tabulate(data, headers=headers))
    out.write("\n")


def make_tag_entries(symbols: Sequence[Symbol], out: TextIO):
    # NOTE from vim's documentation I'm not sure if that has to be first line,
    # or still sorted, also not sure if I 'case-fold' sorted correctly
    header = ["!_TAG_FILE_SORTED\t2\tcase-fold sorted"]
    entries = [
        '%s\t%s\t%d;" %s' % (i.name, i.file, i.line, i.kind_str)
        for i in sorted(symbols, key=lambda s: s.name.lower())
    ]
    out.write("\n".join(header + entries))
    out.write("\n")


def make_vim_telescope_entries(symbols: Sequence[Symbol], out: TextIO):
    out.write(
        "\n".join(
            "\x00".join(
                [
                    s.name,
                    str(s.line),
                    s.kind_str,
                    str(s.file),
                ]
            )
            for s in symbols
        )
    )
    out.write("\n")


log_quiet = False


def log(message: str, end: str = "\n"):
    global log_quiet
    if log_quiet:
        return
    print(message, end=end)


@click.command(
    help="""
        [SOURCES] are folders and files to search.
        Note that they are each considered to be the root for qualified names.
        The qualified names are all relative to the arguments you pass here.
        For example, passing 'python/module/sub/file.py' will register things inside
        'file.py' not qualified as 'module.sub'. For that you should pass 'python'
        as a folder.
    """,
)
@click.argument("sources", nargs=-1)
@click.option(
    "--out",
    "-o",
    default="-",
    help="output file or - for stdout",
    show_default=True,
)
@click.option(
    "--quiet/--no-quiet",
    "-q/",
    default=False,
    help="suppress all output to stdout (except for --out=-)",
    show_default=True,
)
@click.option(
    "--fmt",
    "-f",
    default="human",
    help="formats: human, ctags, vim-telescope",
    show_default=True,
)
def main(out: str, sources: Sequence[str], quiet: bool, fmt: str):
    # TODO arr still, typer could make this much shorter above
    if len(sources) == 0:
        paths = {Path(".")}
    else:
        paths = {Path(s) for s in sources}

    global log_quiet
    log_quiet = quiet

    dt = time.time()
    log("scanning ...", end="")
    symbols = get_symbols_in_sources(paths)
    log(" found %d symbols (%d ms)" % (len(symbols), (time.time() - dt) * 1000))

    match out:
        # NOTE this means we dont support an output file that is actually named "-"
        case "-":
            make_entries(fmt, symbols, sys.stdout)
        case _:
            with Path(out).open("wt") as f:
                make_entries(fmt, symbols, f)


if __name__ == "__main__":
    main()
