#!python-with-venv
# pyright: strict

"""! python3.10 requirements
click==8.1.3
tabulate==0.9.0
ipython==8.11.0
"""

# todo
# - respect PYTHONPATH or whatever python uses to search all relevant locations?
#   - what files are considered is one thing, another is the "bases" for fully qualified names
# - maybe https://pypi.org/project/parso/
# - also treesitter might be able to recover?
# - first just skip file, would be nice if we could at least get the tree up to error?

from __future__ import annotations

import ast  # https://greentreesnakes.readthedocs.io/en/latest/index.html
import os
import os.path
import pathlib
import re
import sys
import time
from ast import AST
from collections.abc import Sequence
from dataclasses import dataclass
from pathlib import Path
from typing import Callable, TextIO

import click
from tabulate import tabulate


@dataclass(frozen=True)
class Symbol(object):
    name: str
    line: int  # 1-based
    kind: str
    file: Path

    def qualified(self, qualifier: str) -> Symbol:
        return Symbol(
            f"{qualifier}.{self.name}",
            self.line,
            self.kind,
            self.file,
        )

    def __str__(self):
        return "%s [%s]" % (self.name, self.kind)


def symbols_qualified(symbols: Sequence[Symbol], qualifier: str) -> list[Symbol]:
    return [s.qualified(qualifier) for s in symbols]


def get_symbols_in_Module(file: Path, node: AST) -> list[Symbol]:

    symbols: list[Symbol] = []

    class V(ast.NodeVisitor):
        def visit_FunctionDef(self, node: ast.FunctionDef):
            symbols.append(Symbol(node.name, node.lineno, "function", file))
            symbols.extend(
                symbols_qualified(
                    get_symbols_in_FunctionDef(file, node.body), node.name
                )
            )

        def visit_ClassDef(self, node: ast.ClassDef):
            symbols.append(Symbol(node.name, node.lineno, "class", file))
            symbols.extend(
                symbols_qualified(get_symbols_in_ClassDef(file, node.body), node.name)
            )

        def visit_Assign(self, node: ast.Assign):
            for t in node.targets:
                for i in ast.walk(t):
                    if isinstance(i, ast.Name):
                        symbols.append(Symbol(i.id, node.lineno, "variable", file))

    V().visit(node)
    return symbols


def get_symbols_in_FunctionDef(file: Path, body: Sequence[ast.stmt]) -> list[Symbol]:

    symbols: list[Symbol] = []

    class V(ast.NodeVisitor):
        def visit_ClassDef(self, node: ast.ClassDef):
            symbols.append(Symbol(node.name, node.lineno, "class", file))
            symbols.extend(
                symbols_qualified(get_symbols_in_ClassDef(file, node.body), node.name)
            )

    # TODO is this necessary? cant we just do it on body?
    # the documentation is not clear even if it goes recursively
    # ah that would work if we didnt pass in body.body
    for i in body:
        # TODO and if we need the loop, dont recreate class
        V().visit(i)

    return symbols


def get_symbols_in_ClassDef(file: Path, body: Sequence[ast.stmt]) -> list[Symbol]:
    return [j for i in body for j in get_symbols_in_Module(file, i)]


def make_entries(fmt: str, symbols: Sequence[Symbol], out: TextIO):
    match fmt:
        case "human":
            make_human_entries(symbols, out)
        case "ctags":
            make_tag_entries(symbols, out)
        case "vim-telescope":
            make_vim_telescope_entries(symbols, out)
        case _:
            assert False, fmt


def make_human_entries(symbols: Sequence[Symbol], out: TextIO):
    headers = ["location", "kind", "name"]
    data = [[f"{s.file}:{s.line}", f"{s.kind}", f"{s.name}"] for s in symbols]
    out.write(tabulate(data, headers=headers))
    out.write("\n")


def make_tag_entries(symbols: Sequence[Symbol], out: TextIO):
    # NOTE from vim's documentation I'm not sure if that has to be first line,
    # or still sorted, also not sure if I 'case-fold' sorted correctly
    header = ["!_TAG_FILE_SORTED\t2\tcase-fold sorted"]
    entries = [
        '%s\t%s\t%d;" %s' % (i.name, i.file, i.line, i.kind)
        # TODO not nice here that s.name could be None, can we statically type this?
        for i in sorted(symbols, key=lambda s: (s.name or "").lower())
    ]
    out.write("\n".join(header + entries))
    out.write("\n")


def make_vim_telescope_entries(symbols: Sequence[Symbol], out: TextIO):
    out.write(
        "\n".join(
            # TODO also here s.file and others could be None :/
            "\x00".join(
                [
                    s.name or "",
                    str(s.line or -1),
                    s.kind or "",
                    str(os.path.abspath(s.file or ".")),
                ]
            )
            for s in symbols
        )
    )
    out.write("\n")


def get_symbols_in_folder(
    folder: Path, should_exclude: Callable[[str], bool]
) -> list[Symbol]:

    symbols: list[Symbol] = []

    for f in folder.iterdir():
        if should_exclude(str(f)):
            continue
        if f.is_dir():
            symbols.extend(
                symbols_qualified(get_symbols_in_folder(f, should_exclude), f.name)
            )
        elif f.name == "__init__.py":
            symbols.extend(get_symbols_in_file(f))
        elif f.suffix == ".py":
            # TODO this way we will miss any hash-banged python files
            # unless they are listed explicitely I think
            symbols.extend(symbols_qualified(get_symbols_in_file(f), f.stem))
        else:
            pass

    return symbols


def get_symbols_in_file(file: Path) -> list[Symbol]:
    try:
        t: AST = ast.parse(file.read_text(), filename=file)
    except SyntaxError as e:
        # TODO better way to handle, exit code, error message
        # or skip or reuse cached for that file?
        print(e)
        return []
    return get_symbols_in_Module(file, t)


def get_symbols_in_sources(
    sources: Sequence[str], excludes: Sequence[str]
) -> list[Symbol]:
    """sources is a list of folder and/or files"""
    exclude_matchers = [re.compile(i) for i in excludes]

    # TODO change to path, also in passed-arg in loop then, twice!
    def should_exclude(p: str) -> bool:
        for m in exclude_matchers:
            if m.fullmatch(p) is not None:
                return True
        return False

    symbols: list[Symbol] = []
    for source in sources:
        if should_exclude(source):
            continue
        sourcep = pathlib.Path(source)
        if sourcep.is_dir():
            symbols.extend(get_symbols_in_folder(sourcep, should_exclude))
        elif sourcep.is_file():
            symbols.extend(get_symbols_in_file(sourcep))
    return symbols


log_quiet = False


def log(message: str, end: str = "\n"):
    global log_quiet
    if log_quiet:
        return
    print(message, end=end)


@click.command()
@click.argument("sources", nargs=-1, type=click.Path(exists=True))
@click.option(
    "--out",
    "-o",
    default="-",
    help="output file or - for stdout",
    show_default=True,
)
@click.option(
    "--quiet/--no-quiet",
    "-q/",
    default=False,
    help="suppress all output to stdout (except for --out=-)",
    show_default=True,
)
@click.option(
    "--fmt",
    "-f",
    default="human",
    help="formats: human, ctags, vim-telescope",
    show_default=True,
)
@click.option(
    "excludes",
    "--exclude",
    "-e",
    default=[],
    multiple=True,
    help="Regexps for paths to exlude. Can be used multiple times.",
    # TODO it's not clear if it's on the full path, or on the path starting with the source entry
)
def main(
    out: str, sources: Sequence[str], quiet: bool, fmt: str, excludes: Sequence[str]
):
    if len(sources) == 0:
        sources = (".",)

    global log_quiet
    log_quiet = quiet

    dt = time.time()
    log("scanning ...", end="")
    symbols = get_symbols_in_sources(sources, excludes)
    log(" found %d symbols (%d ms)" % (len(symbols), (time.time() - dt) * 1000))

    match out:
        # NOTE this means we dont support an output file that is actually named "-"
        case "-":
            make_entries(fmt, symbols, sys.stdout)
        case _:
            with Path(out).open("wt") as f:
                make_entries(fmt, symbols, f)


if __name__ == "__main__":
    main()
