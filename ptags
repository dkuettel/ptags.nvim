#!python-with-venv
# pyright: strict

"""! python3.10 requirements
click==8.1.3
tabulate==0.9.0
ipython==8.11.0
tree_sitter==0.20.1
"""

from __future__ import annotations

import functools
import re
import sys
import time
from collections.abc import Sequence, Set
from dataclasses import dataclass
from enum import Enum
from pathlib import Path
from typing import Callable, Optional, TextIO

import click
from tabulate import tabulate
from tree_sitter import Language, Node, Parser
from tree_sitter.binding import Query


class Kind(Enum):
    FUNCTION = "function"
    CLASS = "class"
    VARIABLE = "variable"


@dataclass(frozen=True)
class Symbol(object):
    qualifiers: tuple[str, ...]
    line: int  # 1-based
    kind: Kind
    file: Path

    @property
    def name(self) -> str:
        return ".".join(self.qualifiers)

    @property
    def kind_str(self) -> str:
        return str(self.kind.value)

    def __str__(self):
        return "%s [%s]" % (self.name, self.kind)


def get_ts_query_for_kind(kind: Kind) -> str:
    match kind:
        case kind.FUNCTION:
            return f"(function_definition name: (identifier) @{kind.value})"
        case kind.CLASS:
            return f"(class_definition name: (identifier) @{kind.value})"
        case kind.VARIABLE:
            return f"(assignment left: (identifier) @{kind.value})"


def get_ts_queries() -> str:
    return "\n".join(get_ts_query_for_kind(k) for k in Kind)


@functools.cache
def ts_setup() -> tuple[Parser, Query]:
    Language.build_library("./my-languages.so", ["tree-sitter-python"])
    language = Language("./my-languages.so", "python")
    parser = Parser()
    parser.set_language(language)
    query = language.query(get_ts_queries())
    return parser, query


def parse_and_capture(file: Path) -> list[tuple[Node, str]]:
    parser, query = ts_setup()
    source = file.read_text().encode("utf8")
    tree = parser.parse(source)
    return query.captures(tree.root_node)


def scope_from_node(node: Node) -> tuple[str, ...]:
    scope: list[str] = []
    at = node.parent
    while at is not None:
        if at.type == "block" and at.parent is not None:
            maybe_name = at.parent.child_by_field_name("name")
            if maybe_name is not None:
                scope.append(maybe_name.text.decode("utf8"))
        at = at.parent
    return tuple(reversed(scope))


def get_symbol_from_capture(
    node: Node, name: str, file: Path, file_scope: tuple[str, ...]
) -> Optional[Symbol]:
    identifier = node.text.decode("utf8")
    scope = scope_from_node(node)
    kind = Kind(name)
    if kind is Kind.VARIABLE and len(scope) > 0:
        return None
    return Symbol(
        file_scope + scope + (identifier,),
        node.start_point[0] + 1,
        kind,
        file,
    )


def get_symbols_in_file(file: Path, file_scope: tuple[str, ...]) -> list[Symbol]:
    # TODO capture error nodes and add to results? how to warn that results are incomplete?
    candidates = parse_and_capture(file)
    maybe_symbols = [
        get_symbol_from_capture(node, name, file, file_scope)
        for node, name in candidates
    ]
    return [s for s in maybe_symbols if s is not None]


def get_symbols_in_folder(
    folder: Path, scope: tuple[str, ...], should_exclude: Callable[[Path], bool]
) -> list[Symbol]:
    # TODO could just start with a **/*.py glob anyway and a basefolder for proper naming
    # easy to understand, easy to parallelize if we need to
    symbols: list[Symbol] = []

    for f in folder.iterdir():
        if should_exclude(f):
            continue
        if f.is_dir():
            symbols.extend(get_symbols_in_folder(f, scope + (f.name,), should_exclude))
        elif f.name == "__init__.py":
            symbols.extend(get_symbols_in_file(f, scope))
        elif f.suffix == ".py":
            # NOTE this way we will miss hash-banged python files
            # (unless they are given explicitely as a file)
            symbols.extend(get_symbols_in_file(f, scope + (f.stem,)))
        else:
            pass

    return symbols


def get_symbols_in_sources(
    sources: Set[Path],
    excludes: Sequence[str],
) -> list[Symbol]:
    """sources is a list of folder and/or files"""
    exclude_matchers = [re.compile(i) for i in excludes]

    def should_exclude(p: Path) -> bool:
        for m in exclude_matchers:
            if m.fullmatch(str(p)) is not None:
                return True
        return False

    symbols: list[Symbol] = []
    for source in sources:
        if should_exclude(source):
            continue
        if source.is_dir():
            symbols.extend(get_symbols_in_folder(source, (), should_exclude))
        elif source.is_file():
            symbols.extend(get_symbols_in_file(source, ()))
    return symbols


def make_entries(fmt: str, symbols: Sequence[Symbol], out: TextIO):
    match fmt:
        case "human":
            make_human_entries(symbols, out)
        case "ctags":
            make_tag_entries(symbols, out)
        case "vim-telescope":
            make_vim_telescope_entries(symbols, out)
        case _:
            assert False, fmt


def make_human_entries(symbols: Sequence[Symbol], out: TextIO):
    headers = ["location", "kind", "name"]
    data = [[f"{s.file}:{s.line}", f"{s.kind_str}", f"{s.name}"] for s in symbols]
    out.write(tabulate(data, headers=headers))
    out.write("\n")


def make_tag_entries(symbols: Sequence[Symbol], out: TextIO):
    # NOTE from vim's documentation I'm not sure if that has to be first line,
    # or still sorted, also not sure if I 'case-fold' sorted correctly
    header = ["!_TAG_FILE_SORTED\t2\tcase-fold sorted"]
    entries = [
        '%s\t%s\t%d;" %s' % (i.name, i.file, i.line, i.kind_str)
        for i in sorted(symbols, key=lambda s: s.name.lower())
    ]
    out.write("\n".join(header + entries))
    out.write("\n")


def make_vim_telescope_entries(symbols: Sequence[Symbol], out: TextIO):
    out.write(
        "\n".join(
            "\x00".join(
                [
                    s.name,
                    str(s.line),
                    s.kind_str,
                    str(s.file),
                ]
            )
            for s in symbols
        )
    )
    out.write("\n")


log_quiet = False


def log(message: str, end: str = "\n"):
    global log_quiet
    if log_quiet:
        return
    print(message, end=end)


@click.command(
    help="""
        [SOURCES] are folders and files to search.
        Note that they are each considered to be the root for qualified names.
        The qualified names are all relative to the arguments you pass here.
        For example, passing 'python/module/sub/file.py' will register things inside
        'file.py' not qualified as 'module.sub'. For that you should pass 'python'
        as a folder.
    """,
)
@click.argument("sources", nargs=-1)
@click.option(
    "--out",
    "-o",
    default="-",
    help="output file or - for stdout",
    show_default=True,
)
@click.option(
    "--quiet/--no-quiet",
    "-q/",
    default=False,
    help="suppress all output to stdout (except for --out=-)",
    show_default=True,
)
@click.option(
    "--fmt",
    "-f",
    default="human",
    help="formats: human, ctags, vim-telescope",
    show_default=True,
)
@click.option(
    "excludes",
    "--exclude",
    "-e",
    default=[],
    multiple=True,
    help="Regexps for paths to exlude. Can be used multiple times.",
    # TODO it's not clear if it's on the full path, or on the path starting with the source entry
    # TODO could we make it a glob, and just find all with glob and remove from set?
    # not so easy, because we do it recursively
)
def main(
    out: str, sources: Sequence[str], quiet: bool, fmt: str, excludes: Sequence[str]
):
    # TODO arr still, typer could make this much shorter above
    if len(sources) == 0:
        paths = {Path(".")}
    else:
        paths = {Path(s) for s in sources}

    global log_quiet
    log_quiet = quiet

    dt = time.time()
    log("scanning ...", end="")
    symbols = get_symbols_in_sources(paths, excludes)
    log(" found %d symbols (%d ms)" % (len(symbols), (time.time() - dt) * 1000))

    match out:
        # NOTE this means we dont support an output file that is actually named "-"
        case "-":
            make_entries(fmt, symbols, sys.stdout)
        case _:
            with Path(out).open("wt") as f:
                make_entries(fmt, symbols, f)


if __name__ == "__main__":
    main()
