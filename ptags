#!python-with-venv
# pyright: strict

"""! python3.10 requirements
click==8.1.3
tabulate==0.9.0
ipython==8.11.0
tree_sitter==0.20.1
"""

from __future__ import annotations

import functools
import re
import sys
import time
from collections.abc import Sequence, Set
from dataclasses import dataclass
from enum import Enum
from pathlib import Path
from typing import Callable, Optional, TextIO

import click
from tabulate import tabulate
from tree_sitter import Language, Node, Parser
from tree_sitter.binding import Query


class Kind(Enum):
    function_def = "function"
    class_def = "class"
    variable = "variable"
    error = "syntax-error"


@dataclass(frozen=True)
class Symbol(object):
    qualifiers: tuple[str, ...]
    line: int  # 1-based
    kind: Kind
    file: Path

    @property
    def name(self) -> str:
        return ".".join(self.qualifiers)

    @property
    def kind_str(self) -> str:
        return str(self.kind.value)

    def __str__(self):
        return "%s [%s]" % (self.name, self.kind)


def get_symbols_in_folder(
    folder: Path, scope: tuple[str, ...], should_exclude: Callable[[Path], bool]
) -> list[Symbol]:
    symbols: list[Symbol] = []

    for f in folder.iterdir():
        if should_exclude(f):
            continue
        if f.is_dir():
            symbols.extend(get_symbols_in_folder(f, scope + (f.name,), should_exclude))
        elif f.name == "__init__.py":
            symbols.extend(get_symbols_in_file(f, scope))
        elif f.suffix == ".py":
            # NOTE this way we will miss hash-banged python files
            # (unless they are given explicitely as a file)
            symbols.extend(get_symbols_in_file(f, scope + (f.stem,)))
        else:
            pass

    return symbols


ts_query = """
(function_definition name: (identifier) @function_name)
(class_definition name: (identifier) @class_name)
(assignment left: (identifier) @variable_name)
"""


def kind_from_capture_name(name: str) -> Kind:
    # TODO we could make that the name of the Kind to start with in captures, direct access Kind[...]
    match name:
        case "function_name":
            return Kind.function_def
        case "class_name":
            return Kind.class_def
        case "variable_name":
            return Kind.variable
        case _:
            assert False


@functools.cache
def ts_setup() -> tuple[Parser, Query]:
    Language.build_library("./my-languages.so", ["tree-sitter-python"])
    language = Language("./my-languages.so", "python")
    parser = Parser()
    parser.set_language(language)
    query = language.query(ts_query)
    return parser, query


def parse_and_capture(file: Path) -> list[tuple[Node, str]]:
    parser, query = ts_setup()
    source = file.read_text("utf8").encode("utf8")
    tree = parser.parse(source)
    return query.captures(tree.root_node)


def ts_qualify(node: Optional[Node]) -> tuple[str, ...]:
    path: list[str] = []
    while node is not None:
        match node.type:
            case "identifier":
                # TODO that's only for the first, add that unconditionally before the climb
                path.append(node.text.decode("utf8"))
            case "block":
                assert node.parent is not None
                maybe_name = node.parent.child_by_field_name("name")
                if maybe_name is not None:
                    path.append(maybe_name.text.decode("utf8"))
            case _:
                pass
        node = node.parent
    return tuple(reversed(path))


# TODO what's the semantics here, should scope not be without file yet?
# probably not because of __init__.py, but can be done differently
def get_symbols_in_file(file: Path, scope: tuple[str, ...]) -> list[Symbol]:
    candidates = parse_and_capture(file)
    # TODO capture error nodes and add to results? how to warn that results are incomplete?
    symbols: list[Symbol] = []
    for node, name in candidates:
        qualifiers = ts_qualify(node)
        match name:
            case "variable_name":
                if len(qualifiers) > 0:
                    continue
            case _:
                pass
        symbols.append(
            Symbol(
                scope + qualifiers,
                node.start_point[0] + 1,
                kind_from_capture_name(name),
                file,
            )
        )
    return symbols


def get_symbols_in_sources(
    sources: Set[Path],
    excludes: Sequence[str],
) -> list[Symbol]:
    """sources is a list of folder and/or files"""
    exclude_matchers = [re.compile(i) for i in excludes]

    def should_exclude(p: Path) -> bool:
        for m in exclude_matchers:
            if m.fullmatch(str(p)) is not None:
                return True
        return False

    symbols: list[Symbol] = []
    for source in sources:
        if should_exclude(source):
            continue
        if source.is_dir():
            symbols.extend(get_symbols_in_folder(source, (), should_exclude))
        elif source.is_file():
            symbols.extend(get_symbols_in_file(source, ()))
    return symbols


def make_entries(fmt: str, symbols: Sequence[Symbol], out: TextIO):
    match fmt:
        case "human":
            make_human_entries(symbols, out)
        case "ctags":
            make_tag_entries(symbols, out)
        case "vim-telescope":
            make_vim_telescope_entries(symbols, out)
        case _:
            assert False, fmt


def make_human_entries(symbols: Sequence[Symbol], out: TextIO):
    headers = ["location", "kind", "name"]
    data = [[f"{s.file}:{s.line}", f"{s.kind_str}", f"{s.name}"] for s in symbols]
    out.write(tabulate(data, headers=headers))
    out.write("\n")


def make_tag_entries(symbols: Sequence[Symbol], out: TextIO):
    # NOTE from vim's documentation I'm not sure if that has to be first line,
    # or still sorted, also not sure if I 'case-fold' sorted correctly
    header = ["!_TAG_FILE_SORTED\t2\tcase-fold sorted"]
    entries = [
        '%s\t%s\t%d;" %s' % (i.name, i.file, i.line, i.kind_str)
        for i in sorted(symbols, key=lambda s: s.name.lower())
    ]
    out.write("\n".join(header + entries))
    out.write("\n")


def make_vim_telescope_entries(symbols: Sequence[Symbol], out: TextIO):
    out.write(
        "\n".join(
            "\x00".join(
                [
                    s.name,
                    str(s.line),
                    s.kind_str,
                    str(s.file),
                ]
            )
            for s in symbols
        )
    )
    out.write("\n")


log_quiet = False


def log(message: str, end: str = "\n"):
    global log_quiet
    if log_quiet:
        return
    print(message, end=end)


@click.command(
    help="""
        [SOURCES] are folders and files to search.
        Note that they are each considered to be the root for qualified names.
        The qualified names are all relative to the arguments you pass here.
        For example, passing 'python/module/sub/file.py' will register things inside
        'file.py' not qualified as 'module.sub'. For that you should pass 'python'
        as a folder.
    """,
)
@click.argument("sources", nargs=-1)
@click.option(
    "--out",
    "-o",
    default="-",
    help="output file or - for stdout",
    show_default=True,
)
@click.option(
    "--quiet/--no-quiet",
    "-q/",
    default=False,
    help="suppress all output to stdout (except for --out=-)",
    show_default=True,
)
@click.option(
    "--fmt",
    "-f",
    default="human",
    help="formats: human, ctags, vim-telescope",
    show_default=True,
)
@click.option(
    "excludes",
    "--exclude",
    "-e",
    default=[],
    multiple=True,
    help="Regexps for paths to exlude. Can be used multiple times.",
    # TODO it's not clear if it's on the full path, or on the path starting with the source entry
    # TODO could we make it a glob, and just find all with glob and remove from set?
    # not so easy, because we do it recursively
)
def main(
    out: str, sources: Sequence[str], quiet: bool, fmt: str, excludes: Sequence[str]
):
    # TODO arr still, typer could make this much shorter above
    if len(sources) == 0:
        paths = {Path(".")}
    else:
        paths = {Path(s) for s in sources}

    global log_quiet
    log_quiet = quiet

    dt = time.time()
    log("scanning ...", end="")
    symbols = get_symbols_in_sources(paths, excludes)
    log(" found %d symbols (%d ms)" % (len(symbols), (time.time() - dt) * 1000))

    match out:
        # NOTE this means we dont support an output file that is actually named "-"
        case "-":
            make_entries(fmt, symbols, sys.stdout)
        case _:
            with Path(out).open("wt") as f:
                make_entries(fmt, symbols, f)


if __name__ == "__main__":
    main()
